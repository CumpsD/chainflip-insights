//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> FundingStorage
    /// </summary>
    public sealed class FundingStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> FundingStorage Constructor
        /// </summary>
        public FundingStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "ActiveBidder"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Primitive.Bool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "PendingRedemptions"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApiExt.Generated.Model.pallet_cf_funding.PendingRedemptionInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "MinimumFunding"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "RedemptionTTLSeconds"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U64)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "BoundExecutorAddress"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApiExt.Generated.Model.primitive_types.H160)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "RestrictedAddresses"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApiExt.Generated.Model.primitive_types.H160), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "RestrictedBalances"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApiExt.Generated.Types.Base.BTreeMapT1)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "BoundRedeemAddress"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApiExt.Generated.Model.primitive_types.H160)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Funding", "RedemptionTax"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
        }
        
        /// <summary>
        /// >> ActiveBidderParams
        ///  Store the list of funded accounts and whether or not they are a active bidder.
        /// </summary>
        public static string ActiveBidderParams(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Funding", "ActiveBidder", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ActiveBidderDefault
        /// Default value as hex string
        /// </summary>
        public static string ActiveBidderDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ActiveBidder
        ///  Store the list of funded accounts and whether or not they are a active bidder.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.Bool> ActiveBidder(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.ActiveBidderParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.Bool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PendingRedemptionsParams
        ///  PendingRedemptions stores a Pending enum for the account until the redemption is executed
        ///  or the redemption expires.
        /// </summary>
        public static string PendingRedemptionsParams(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Funding", "PendingRedemptions", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PendingRedemptionsDefault
        /// Default value as hex string
        /// </summary>
        public static string PendingRedemptionsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> PendingRedemptions
        ///  PendingRedemptions stores a Pending enum for the account until the redemption is executed
        ///  or the redemption expires.
        /// </summary>
        public async Task<Substrate.NetApiExt.Generated.Model.pallet_cf_funding.PendingRedemptionInfo> PendingRedemptions(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.PendingRedemptionsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApiExt.Generated.Model.pallet_cf_funding.PendingRedemptionInfo>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinimumFundingParams
        ///  The minimum amount a user can fund their account with, and therefore the minimum balance
        ///  they must have remaining after they redeem.
        /// </summary>
        public static string MinimumFundingParams()
        {
            return RequestGenerator.GetStorage("Funding", "MinimumFunding", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumFundingDefault
        /// Default value as hex string
        /// </summary>
        public static string MinimumFundingDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinimumFunding
        ///  The minimum amount a user can fund their account with, and therefore the minimum balance
        ///  they must have remaining after they redeem.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinimumFunding(string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.MinimumFundingParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RedemptionTTLSecondsParams
        ///  TTL for a redemption from the moment of issue.
        /// </summary>
        public static string RedemptionTTLSecondsParams()
        {
            return RequestGenerator.GetStorage("Funding", "RedemptionTTLSeconds", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> RedemptionTTLSecondsDefault
        /// Default value as hex string
        /// </summary>
        public static string RedemptionTTLSecondsDefault()
        {
            return "0x0000000000000000";
        }
        
        /// <summary>
        /// >> RedemptionTTLSeconds
        ///  TTL for a redemption from the moment of issue.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U64> RedemptionTTLSeconds(string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.RedemptionTTLSecondsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U64>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BoundExecutorAddressParams
        ///  Registered addresses for an executor.
        /// </summary>
        public static string BoundExecutorAddressParams(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Funding", "BoundExecutorAddress", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> BoundExecutorAddressDefault
        /// Default value as hex string
        /// </summary>
        public static string BoundExecutorAddressDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> BoundExecutorAddress
        ///  Registered addresses for an executor.
        /// </summary>
        public async Task<Substrate.NetApiExt.Generated.Model.primitive_types.H160> BoundExecutorAddress(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.BoundExecutorAddressParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApiExt.Generated.Model.primitive_types.H160>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RestrictedAddressesParams
        ///  List of restricted addresses
        /// </summary>
        public static string RestrictedAddressesParams(Substrate.NetApiExt.Generated.Model.primitive_types.H160 key)
        {
            return RequestGenerator.GetStorage("Funding", "RestrictedAddresses", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> RestrictedAddressesDefault
        /// Default value as hex string
        /// </summary>
        public static string RestrictedAddressesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> RestrictedAddresses
        ///  List of restricted addresses
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple> RestrictedAddresses(Substrate.NetApiExt.Generated.Model.primitive_types.H160 key, string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.RestrictedAddressesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RestrictedBalancesParams
        ///  Map that bookkeeps the restricted balances for each address
        /// </summary>
        public static string RestrictedBalancesParams(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Funding", "RestrictedBalances", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> RestrictedBalancesDefault
        /// Default value as hex string
        /// </summary>
        public static string RestrictedBalancesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> RestrictedBalances
        ///  Map that bookkeeps the restricted balances for each address
        /// </summary>
        public async Task<Substrate.NetApiExt.Generated.Types.Base.BTreeMapT1> RestrictedBalances(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.RestrictedBalancesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApiExt.Generated.Types.Base.BTreeMapT1>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BoundRedeemAddressParams
        ///  Map of bound addresses for accounts.
        /// </summary>
        public static string BoundRedeemAddressParams(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Funding", "BoundRedeemAddress", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> BoundRedeemAddressDefault
        /// Default value as hex string
        /// </summary>
        public static string BoundRedeemAddressDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> BoundRedeemAddress
        ///  Map of bound addresses for accounts.
        /// </summary>
        public async Task<Substrate.NetApiExt.Generated.Model.primitive_types.H160> BoundRedeemAddress(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.BoundRedeemAddressParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApiExt.Generated.Model.primitive_types.H160>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RedemptionTaxParams
        ///  The fee levied for every redemption request. Can be updated by Governance.
        /// </summary>
        public static string RedemptionTaxParams()
        {
            return RequestGenerator.GetStorage("Funding", "RedemptionTax", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> RedemptionTaxDefault
        /// Default value as hex string
        /// </summary>
        public static string RedemptionTaxDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> RedemptionTax
        ///  The fee levied for every redemption request. Can be updated by Governance.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> RedemptionTax(string blockhash, CancellationToken token)
        {
            string parameters = FundingStorage.RedemptionTaxParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> FundingCalls
    /// </summary>
    public sealed class FundingCalls
    {
        
        /// <summary>
        /// >> funded
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Funded(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 account_id, Substrate.NetApi.Model.Types.Primitive.U128 amount, Substrate.NetApiExt.Generated.Model.primitive_types.H160 funder, Substrate.NetApiExt.Generated.Types.Base.Arr32U8 tx_hash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(account_id.Encode());
            byteArray.AddRange(amount.Encode());
            byteArray.AddRange(funder.Encode());
            byteArray.AddRange(tx_hash.Encode());
            return new Method(5, "Funding", 0, "funded", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> redeem
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Redeem(Substrate.NetApiExt.Generated.Model.pallet_cf_funding.pallet.EnumRedemptionAmount amount, Substrate.NetApiExt.Generated.Model.primitive_types.H160 address, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApiExt.Generated.Model.primitive_types.H160> executor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(amount.Encode());
            byteArray.AddRange(address.Encode());
            byteArray.AddRange(executor.Encode());
            return new Method(5, "Funding", 1, "redeem", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> redeemed
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Redeemed(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 account_id, Substrate.NetApi.Model.Types.Primitive.U128 redeemed_amount, Substrate.NetApiExt.Generated.Types.Base.Arr32U8 tx_hash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(account_id.Encode());
            byteArray.AddRange(redeemed_amount.Encode());
            byteArray.AddRange(tx_hash.Encode());
            return new Method(5, "Funding", 2, "redeemed", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> redemption_expired
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RedemptionExpired(Substrate.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 account_id, Substrate.NetApi.Model.Types.Primitive.U64 block_number)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(account_id.Encode());
            byteArray.AddRange(block_number.Encode());
            return new Method(5, "Funding", 3, "redemption_expired", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> stop_bidding
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method StopBidding()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(5, "Funding", 4, "stop_bidding", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> start_bidding
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method StartBidding()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(5, "Funding", 5, "start_bidding", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_minimum_funding
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateMinimumFunding(Substrate.NetApi.Model.Types.Primitive.U128 minimum_funding)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(minimum_funding.Encode());
            return new Method(5, "Funding", 6, "update_minimum_funding", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_restricted_addresses
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateRestrictedAddresses(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApiExt.Generated.Model.primitive_types.H160> addresses_to_add, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApiExt.Generated.Model.primitive_types.H160> addresses_to_remove)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(addresses_to_add.Encode());
            byteArray.AddRange(addresses_to_remove.Encode());
            return new Method(5, "Funding", 7, "update_restricted_addresses", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bind_redeem_address
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method BindRedeemAddress(Substrate.NetApiExt.Generated.Model.primitive_types.H160 address)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(address.Encode());
            return new Method(5, "Funding", 8, "bind_redeem_address", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_redemption_tax
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateRedemptionTax(Substrate.NetApi.Model.Types.Primitive.U128 amount)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(amount.Encode());
            return new Method(5, "Funding", 9, "update_redemption_tax", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bind_executor_address
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method BindExecutorAddress(Substrate.NetApiExt.Generated.Model.primitive_types.H160 executor_address)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(executor_address.Encode());
            return new Method(5, "Funding", 10, "bind_executor_address", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> FundingConstants
    /// </summary>
    public sealed class FundingConstants
    {
    }
    
    /// <summary>
    /// >> FundingErrors
    /// </summary>
    public enum FundingErrors
    {
        
        /// <summary>
        /// >> NoPendingRedemption
        /// An invalid redemption has been witnessed: the account has no pending redemptions.
        /// </summary>
        NoPendingRedemption,
        
        /// <summary>
        /// >> PendingRedemption
        /// The redeemer tried to redeem despite having a redemption already pending.
        /// </summary>
        PendingRedemption,
        
        /// <summary>
        /// >> AlreadyNotBidding
        /// Can't stop bidding an account if it's already not bidding.
        /// </summary>
        AlreadyNotBidding,
        
        /// <summary>
        /// >> AlreadyBidding
        /// Can only start bidding if not already bidding.
        /// </summary>
        AlreadyBidding,
        
        /// <summary>
        /// >> AuctionPhase
        /// We are in the auction phase
        /// </summary>
        AuctionPhase,
        
        /// <summary>
        /// >> BelowMinimumFunding
        /// When requesting a redemption, you must not have an amount below the minimum.
        /// </summary>
        BelowMinimumFunding,
        
        /// <summary>
        /// >> InsufficientUnrestrictedFunds
        /// There are not enough unrestricted funds to process the redemption.
        /// </summary>
        InsufficientUnrestrictedFunds,
        
        /// <summary>
        /// >> InvalidMinimumFundingUpdate
        /// Minimum funding amount must be greater than the redemption tax.
        /// </summary>
        InvalidMinimumFundingUpdate,
        
        /// <summary>
        /// >> InvalidRedemptionTaxUpdate
        /// Redemption tax must be less than the minimum funding amount.
        /// </summary>
        InvalidRedemptionTaxUpdate,
        
        /// <summary>
        /// >> InsufficientBalance
        /// The account has insufficient funds to pay for the redemption.
        /// </summary>
        InsufficientBalance,
        
        /// <summary>
        /// >> AccountAlreadyBound
        /// The account is already bound to an address.
        /// </summary>
        AccountAlreadyBound,
        
        /// <summary>
        /// >> AccountBindingRestrictionViolated
        /// The account is bound to a withdrawal address.
        /// </summary>
        AccountBindingRestrictionViolated,
        
        /// <summary>
        /// >> RedeemDisabled
        /// Redeem is disabled due to Safe Mode.
        /// </summary>
        RedeemDisabled,
        
        /// <summary>
        /// >> StartBiddingDisabled
        /// Start Bidding is disabled due to Safe Mode.
        /// </summary>
        StartBiddingDisabled,
        
        /// <summary>
        /// >> StopBiddingDisabled
        /// Stop Bidding is disabled due to Safe Mode.
        /// </summary>
        StopBiddingDisabled,
        
        /// <summary>
        /// >> ExecutorBindingRestrictionViolated
        /// The executor for this account is bound to another address.
        /// </summary>
        ExecutorBindingRestrictionViolated,
        
        /// <summary>
        /// >> ExecutorAddressAlreadyBound
        /// The account is already bound to an executor address.
        /// </summary>
        ExecutorAddressAlreadyBound,
    }
}
