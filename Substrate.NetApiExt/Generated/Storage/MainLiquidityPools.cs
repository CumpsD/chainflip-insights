//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> LiquidityPoolsStorage
    /// </summary>
    public sealed class LiquidityPoolsStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> LiquidityPoolsStorage Constructor
        /// </summary>
        public LiquidityPoolsStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityPools", "Pools"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.AssetPair), typeof(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.Pool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityPools", "FlipBuyInterval"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityPools", "CollectedNetworkFee"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityPools", "ScheduledLimitOrderUpdates"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.LimitOrderUpdate>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityPools", "MaximumPriceImpact"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.AssetPair), typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
        }
        
        /// <summary>
        /// >> PoolsParams
        ///  All the available pools.
        /// </summary>
        public static string PoolsParams(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.AssetPair key)
        {
            return RequestGenerator.GetStorage("LiquidityPools", "Pools", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PoolsDefault
        /// Default value as hex string
        /// </summary>
        public static string PoolsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Pools
        ///  All the available pools.
        /// </summary>
        public async Task<Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.Pool> Pools(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.AssetPair key, string blockhash, CancellationToken token)
        {
            string parameters = LiquidityPoolsStorage.PoolsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.Pool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> FlipBuyIntervalParams
        ///  Interval at which we buy FLIP in order to burn it.
        /// </summary>
        public static string FlipBuyIntervalParams()
        {
            return RequestGenerator.GetStorage("LiquidityPools", "FlipBuyInterval", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> FlipBuyIntervalDefault
        /// Default value as hex string
        /// </summary>
        public static string FlipBuyIntervalDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> FlipBuyInterval
        ///  Interval at which we buy FLIP in order to burn it.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> FlipBuyInterval(string blockhash, CancellationToken token)
        {
            string parameters = LiquidityPoolsStorage.FlipBuyIntervalParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectedNetworkFeeParams
        ///  Network fees, in USDC terms, that have been collected and are ready to be converted to FLIP.
        /// </summary>
        public static string CollectedNetworkFeeParams()
        {
            return RequestGenerator.GetStorage("LiquidityPools", "CollectedNetworkFee", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CollectedNetworkFeeDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectedNetworkFeeDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> CollectedNetworkFee
        ///  Network fees, in USDC terms, that have been collected and are ready to be converted to FLIP.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> CollectedNetworkFee(string blockhash, CancellationToken token)
        {
            string parameters = LiquidityPoolsStorage.CollectedNetworkFeeParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ScheduledLimitOrderUpdatesParams
        ///  Queue of limit orders, indexed by block number waiting to get minted or burned.
        /// </summary>
        public static string ScheduledLimitOrderUpdatesParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("LiquidityPools", "ScheduledLimitOrderUpdates", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ScheduledLimitOrderUpdatesDefault
        /// Default value as hex string
        /// </summary>
        public static string ScheduledLimitOrderUpdatesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ScheduledLimitOrderUpdates
        ///  Queue of limit orders, indexed by block number waiting to get minted or burned.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.LimitOrderUpdate>> ScheduledLimitOrderUpdates(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = LiquidityPoolsStorage.ScheduledLimitOrderUpdatesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.LimitOrderUpdate>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaximumPriceImpactParams
        ///  Maximum price impact for a single swap, measured in number of ticks. Configurable
        ///  for each pool.
        /// </summary>
        public static string MaximumPriceImpactParams(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.AssetPair key)
        {
            return RequestGenerator.GetStorage("LiquidityPools", "MaximumPriceImpact", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> MaximumPriceImpactDefault
        /// Default value as hex string
        /// </summary>
        public static string MaximumPriceImpactDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaximumPriceImpact
        ///  Maximum price impact for a single swap, measured in number of ticks. Configurable
        ///  for each pool.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaximumPriceImpact(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.AssetPair key, string blockhash, CancellationToken token)
        {
            string parameters = LiquidityPoolsStorage.MaximumPriceImpactParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> LiquidityPoolsCalls
    /// </summary>
    public sealed class LiquidityPoolsCalls
    {
        
        /// <summary>
        /// >> update_buy_interval
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateBuyInterval(Substrate.NetApi.Model.Types.Primitive.U32 new_buy_interval)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(new_buy_interval.Encode());
            return new Method(35, "LiquidityPools", 0, "update_buy_interval", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> new_pool
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method NewPool(Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset base_asset, Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset quote_asset, Substrate.NetApi.Model.Types.Primitive.U32 fee_hundredth_pips, Substrate.NetApiExt.Generated.Model.primitive_types.U256 initial_price)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(base_asset.Encode());
            byteArray.AddRange(quote_asset.Encode());
            byteArray.AddRange(fee_hundredth_pips.Encode());
            byteArray.AddRange(initial_price.Encode());
            return new Method(35, "LiquidityPools", 2, "new_pool", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_range_order
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateRangeOrder(Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset base_asset, Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset quote_asset, Substrate.NetApi.Model.Types.Primitive.U64 id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApiExt.Generated.Types.Base.Range> option_tick_range, Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.EnumIncreaseOrDecrease size_change)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(base_asset.Encode());
            byteArray.AddRange(quote_asset.Encode());
            byteArray.AddRange(id.Encode());
            byteArray.AddRange(option_tick_range.Encode());
            byteArray.AddRange(size_change.Encode());
            return new Method(35, "LiquidityPools", 3, "update_range_order", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_range_order
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetRangeOrder(Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset base_asset, Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset quote_asset, Substrate.NetApi.Model.Types.Primitive.U64 id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApiExt.Generated.Types.Base.Range> option_tick_range, Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.EnumRangeOrderSize size)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(base_asset.Encode());
            byteArray.AddRange(quote_asset.Encode());
            byteArray.AddRange(id.Encode());
            byteArray.AddRange(option_tick_range.Encode());
            byteArray.AddRange(size.Encode());
            return new Method(35, "LiquidityPools", 4, "set_range_order", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_limit_order
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdateLimitOrder(Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset base_asset, Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset quote_asset, Substrate.NetApiExt.Generated.Model.cf_amm.common.EnumSide side, Substrate.NetApi.Model.Types.Primitive.U64 id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.I32> option_tick, Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.EnumIncreaseOrDecrease amount_change)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(base_asset.Encode());
            byteArray.AddRange(quote_asset.Encode());
            byteArray.AddRange(side.Encode());
            byteArray.AddRange(id.Encode());
            byteArray.AddRange(option_tick.Encode());
            byteArray.AddRange(amount_change.Encode());
            return new Method(35, "LiquidityPools", 5, "update_limit_order", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_limit_order
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetLimitOrder(Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset base_asset, Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset quote_asset, Substrate.NetApiExt.Generated.Model.cf_amm.common.EnumSide side, Substrate.NetApi.Model.Types.Primitive.U64 id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.I32> option_tick, Substrate.NetApi.Model.Types.Primitive.U128 sell_amount)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(base_asset.Encode());
            byteArray.AddRange(quote_asset.Encode());
            byteArray.AddRange(side.Encode());
            byteArray.AddRange(id.Encode());
            byteArray.AddRange(option_tick.Encode());
            byteArray.AddRange(sell_amount.Encode());
            return new Method(35, "LiquidityPools", 6, "set_limit_order", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_pool_fees
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetPoolFees(Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset base_asset, Substrate.NetApiExt.Generated.Model.cf_primitives.chains.assets.any.EnumAsset quote_asset, Substrate.NetApi.Model.Types.Primitive.U32 fee_hundredth_pips)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(base_asset.Encode());
            byteArray.AddRange(quote_asset.Encode());
            byteArray.AddRange(fee_hundredth_pips.Encode());
            return new Method(35, "LiquidityPools", 7, "set_pool_fees", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> schedule_limit_order_update
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ScheduleLimitOrderUpdate(Substrate.NetApiExt.Generated.Model.pallet_cf_pools.pallet.EnumCall call, Substrate.NetApi.Model.Types.Primitive.U32 dispatch_at)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(call.Encode());
            byteArray.AddRange(dispatch_at.Encode());
            return new Method(35, "LiquidityPools", 8, "schedule_limit_order_update", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_maximum_price_impact
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetMaximumPriceImpact(Substrate.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT11 limits)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(limits.Encode());
            return new Method(35, "LiquidityPools", 9, "set_maximum_price_impact", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> LiquidityPoolsConstants
    /// </summary>
    public sealed class LiquidityPoolsConstants
    {
        
        /// <summary>
        /// >> NetworkFee
        /// </summary>
        public Substrate.NetApiExt.Generated.Model.sp_arithmetic.per_things.Permill NetworkFee()
        {
            var result = new Substrate.NetApiExt.Generated.Model.sp_arithmetic.per_things.Permill();
            result.Create("0xE8030000");
            return result;
        }
    }
    
    /// <summary>
    /// >> LiquidityPoolsErrors
    /// </summary>
    public enum LiquidityPoolsErrors
    {
        
        /// <summary>
        /// >> ZeroBuyIntervalNotAllowed
        /// Setting the buy interval to zero is not allowed.
        /// </summary>
        ZeroBuyIntervalNotAllowed,
        
        /// <summary>
        /// >> PoolAlreadyExists
        /// The specified exchange pool already exists.
        /// </summary>
        PoolAlreadyExists,
        
        /// <summary>
        /// >> PoolDoesNotExist
        /// The specified exchange pool does not exist.
        /// </summary>
        PoolDoesNotExist,
        
        /// <summary>
        /// >> UnspecifiedOrderPrice
        /// For previously unused order ids, you must specific a tick/tick range for the order,
        /// thereby specifying the order price associated with that order id
        /// </summary>
        UnspecifiedOrderPrice,
        
        /// <summary>
        /// >> PoolDisabled
        /// The exchange pool is currently disabled.
        /// </summary>
        PoolDisabled,
        
        /// <summary>
        /// >> InvalidFeeAmount
        /// the Fee BIPs must be within the allowed range.
        /// </summary>
        InvalidFeeAmount,
        
        /// <summary>
        /// >> InvalidInitialPrice
        /// the initial price must be within the allowed range.
        /// </summary>
        InvalidInitialPrice,
        
        /// <summary>
        /// >> InvalidTickRange
        /// The Upper or Lower tick is invalid.
        /// </summary>
        InvalidTickRange,
        
        /// <summary>
        /// >> InvalidTick
        /// The tick is invalid.
        /// </summary>
        InvalidTick,
        
        /// <summary>
        /// >> MaximumGrossLiquidity
        /// One of the referenced ticks reached its maximum gross liquidity
        /// </summary>
        MaximumGrossLiquidity,
        
        /// <summary>
        /// >> OrderDoesNotExist
        /// The user's order does not exist.
        /// </summary>
        OrderDoesNotExist,
        
        /// <summary>
        /// >> MaximumPoolInstances
        /// It is no longer possible to mint limit orders due to reaching the maximum pool
        /// instances, other than for ticks where a fixed pool currently exists.
        /// </summary>
        MaximumPoolInstances,
        
        /// <summary>
        /// >> InsufficientLiquidity
        /// The pool does not have enough liquidity left to process the swap.
        /// </summary>
        InsufficientLiquidity,
        
        /// <summary>
        /// >> OutputOverflow
        /// The swap output is past the maximum allowed amount.
        /// </summary>
        OutputOverflow,
        
        /// <summary>
        /// >> AssetRatioUnachieveable
        /// There are no amounts between the specified maximum and minimum that match the required
        /// ratio of assets
        /// </summary>
        AssetRatioUnachieveable,
        
        /// <summary>
        /// >> UpdatingLimitOrdersDisabled
        /// Updating Limit Orders is disabled.
        /// </summary>
        UpdatingLimitOrdersDisabled,
        
        /// <summary>
        /// >> UpdatingRangeOrdersDisabled
        /// Updating Range Orders is disabled.
        /// </summary>
        UpdatingRangeOrdersDisabled,
        
        /// <summary>
        /// >> UnsupportedCall
        /// Unsupported call.
        /// </summary>
        UnsupportedCall,
        
        /// <summary>
        /// >> LimitOrderUpdateExpired
        /// The update can't be scheduled because it has expired (dispatch_at is in the past).
        /// </summary>
        LimitOrderUpdateExpired,
    }
}
